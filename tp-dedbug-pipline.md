# TP - Debug de Pipeline CI/CD GitLab

## üéØ Objectif

Identifier et corriger les erreurs dans des pipelines GitLab CI/CD cass√©s. Chaque sc√©nario repr√©sente un probl√®me r√©el rencontr√© en production.

**Dur√©e estim√©e : 60 minutes**

---

## üîß Sc√©nario 1 : Le Pipeline qui ne d√©marre pas (10 min)

### Contexte
Vous venez de r√©cup√©rer ce pipeline d'un coll√®gue, mais GitLab refuse de le lancer et affiche : **"CI configuration is invalid"**

```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  
build-app:
  stage: build
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - python -m py_compile app.py
  artifacts:
    paths:
      - app.py
    expire_in: 1 day

test-app
  stage: test
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - pip install pytest
    - pytest tests/
  dependencies:
    - build-app

deploy-staging:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Deploying to staging..."
    - ./deploy.sh staging
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - master
  when: manual
```

### üïµÔ∏è Mission
1. **Trouvez les 3 erreurs de syntaxe** qui emp√™chent le pipeline de d√©marrer
2. **Corrigez le fichier** `.gitlab-ci.yml`
3. **Expliquez** chaque erreur trouv√©e

### üí° Indices
- V√©rifiez les deux-points (`:`)
- Regardez attentivement la structure YAML
- GitLab CI/CD est sensible √† l'indentation

---

## üêõ Sc√©nario 2 : Le Job qui √©choue myst√©rieusement (15 min)

### Contexte
Votre pipeline d√©marre mais le job `build-docker` √©choue syst√©matiquement avec l'erreur :
```
ERROR: Cannot connect to the Docker daemon. Is the docker daemon running?
```

```yaml
stages:
  - build
  - package

build-app:
  stage: build
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - python setup.py build
  artifacts:
    paths:
      - dist/
    expire_in: 1 week

build-docker:
  stage: package
  image: docker:latest
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  dependencies:
    - build-app
  only:
    - main
```

### üïµÔ∏è Mission
1. **Identifiez le probl√®me** qui emp√™che Docker de fonctionner
2. **Corrigez le job** pour qu'il puisse ex√©cuter des commandes Docker
3. **Optimisez** : r√©organisez les commandes dans le bon ordre
4. **Bonus** : Ajoutez une gestion d'erreur si le build √©choue

### üí° Indices
- Docker-in-Docker n√©cessite un service sp√©cial
- L'ordre des op√©rations Docker est important (login avant push !)

---

## üîÑ Sc√©nario 3 : Les d√©pendances circulaires (10 min)

### Contexte
Le pipeline se bloque ind√©finiment et GitLab affiche : **"Jobs are waiting for dependent jobs to complete"**

```yaml
stages:
  - prepare
  - build
  - test
  - package

install-deps:
  stage: prepare
  image: python:3.9
  script:
    - pip install -r requirements.txt --target ./libs
  artifacts:
    paths:
      - libs/
  needs:
    - lint-code

build-app:
  stage: build
  image: python:3.9
  script:
    - export PYTHONPATH=$PYTHONPATH:./libs
    - python -m py_compile app.py
  needs:
    - install-deps
    - unit-tests

unit-tests:
  stage: test
  image: python:3.9
  script:
    - export PYTHONPATH=$PYTHONPATH:./libs
    - pytest tests/unit/
  needs:
    - install-deps
    - build-app

lint-code:
  stage: test
  image: python:3.9
  script:
    - pip install flake8
    - flake8 .
  needs:
    - build-app

package-app:
  stage: package
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t myapp .
  needs:
    - build-app
```

### üïµÔ∏è Mission
1. **Dessinez le graphe des d√©pendances** entre les jobs
2. **Identifiez le cycle** qui bloque le pipeline
3. **Corrigez les d√©pendances** pour cr√©er un flux logique
4. **Expliquez** l'ordre d'ex√©cution optimal

### üí° Indices
- Un job ne peut pas d√©pendre d'un job qui d√©pend de lui (directement ou indirectement)
- Les jobs d'un m√™me stage ne peuvent pas se d√©pendre mutuellement avec `needs`

---

## üíæ Sc√©nario 4 : Les artifacts fant√¥mes (10 min)

### Contexte
Votre job `deploy` √©choue avec : **"No files to upload"** ou ne trouve pas les fichiers build√©s.

```yaml
stages:
  - build
  - test
  - deploy

build:
  stage: build
  image: node:16
  script:
    - npm install
    - npm run build
    - ls -la dist/
  artifacts:
    paths:
      - build/
    expire_in: 1 hour

test:
  stage: test
  image: node:16
  script:
    - npm install
    - npm test
  dependencies: []

deploy:
  stage: deploy
  image: alpine:latest
  script:
    - ls -la
    - echo "Fichiers disponibles:"
    - find . -type f
    - cp -r dist/* /var/www/html/
  dependencies:
    - build
  only:
    - main
```

### üïµÔ∏è Mission
1. **Identifiez l'erreur** entre le chemin des artifacts et leur utilisation
2. **Corrigez** pour que les fichiers soient disponibles dans le job `deploy`
3. **V√©rifiez** que les chemins sont coh√©rents
4. **Ajoutez** une v√©rification pour s'assurer que les fichiers existent avant le d√©ploiement

### üí° Indices
- Le chemin dans `artifacts.paths` doit correspondre au chemin cr√©√© par le build
- La commande `npm run build` cr√©e souvent un dossier `dist/` ou `build/`

---

## üîê Sc√©nario 5 : Les variables manquantes (15 min)

### Contexte
Le job √©choue avec des erreurs myst√©rieuses li√©es aux credentials et √† la connexion.

```yaml
stages:
  - deploy

deploy-production:
  stage: deploy
  image: alpine:latest
  script:
    - apk add --no-cache curl
    - echo "Deploying to $DEPLOY_SERVER"
    - curl -X POST https://$DEPLOY_SERVER/api/deploy \
        -H "Authorization: Bearer $API_TOKEN" \
        -d "version=$CI_COMMIT_SHA"
    - ssh $SSH_USER@$DEPLOY_SERVER "docker pull $DOCKER_IMAGE"
    - ssh $SSH_USER@$DEPLOY_SERVER "docker run -d $DOCKER_IMAGE"
  environment:
    name: production
    url: https://$PRODUCTION_URL
  only:
    - tags
```

**Logs d'erreur :**
```
Deploying to
curl: (6) Could not resolve host: 
ssh: Could not resolve hostname : Name or service not known
```

### üïµÔ∏è Mission
1. **Listez toutes les variables** utilis√©es mais non d√©finies
2. **Ajoutez la section `variables`** avec des valeurs de d√©monstration
3. **Identifiez** quelles variables devraient √™tre des **secrets GitLab CI/CD**
4. **Documentez** comment configurer ces secrets dans GitLab
5. **Bonus** : Ajoutez des v√©rifications pour s'assurer que les variables requises existent

### üí° Indices
- Les variables sensibles (tokens, passwords) ne doivent JAMAIS √™tre dans le `.gitlab-ci.yml`
- Utilisez `Settings > CI/CD > Variables` dans GitLab
- Vous pouvez v√©rifier l'existence d'une variable avec `${VAR:?Variable VAR is required}`

---

## ‚ö° Sc√©nario 6 : Le pipeline trop lent (Bonus, 10 min)

### Contexte
Votre pipeline fonctionne mais prend 25 minutes alors qu'il pourrait √™tre beaucoup plus rapide !

```yaml
stages:
  - test

unit-tests:
  stage: test
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - pytest tests/unit/ -v

integration-tests:
  stage: test
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - pytest tests/integration/ -v

e2e-tests:
  stage: test
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - pytest tests/e2e/ -v

security-tests:
  stage: test
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - pip install bandit safety
    - bandit -r .
    - safety check

lint:
  stage: test
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - pip install flake8 black
    - flake8 .
    - black --check .
```

### üïµÔ∏è Mission
1. **Identifiez les optimisations** possibles (au moins 4)
2. **R√©organisez le pipeline** pour gagner du temps
3. **Ajoutez du cache** pour les d√©pendances
4. **Cr√©ez un stage `prepare`** pour mutualiser les installations
5. **Calculez** le temps gagn√© estim√©

### üí° Pistes d'optimisation
- Cache des d√©pendances pip
- Parall√©lisation des jobs
- Artifacts pour partager les installations
- Images Docker pr√©-configur√©es
- √âliminer les installations redondantes

---

## üìä Grille d'√©valuation

| Sc√©nario | Difficult√© | Points | Comp√©tences test√©es |
|----------|-----------|--------|---------------------|
| Sc√©nario 1 | ‚≠ê Facile | 10 pts | Syntaxe YAML, structure de base |
| Sc√©nario 2 | ‚≠ê‚≠ê Moyen | 15 pts | Services Docker, ordre des op√©rations |
| Sc√©nario 3 | ‚≠ê‚≠ê‚≠ê Difficile | 20 pts | D√©pendances, graphe d'ex√©cution |
| Sc√©nario 4 | ‚≠ê‚≠ê Moyen | 15 pts | Artifacts, chemins de fichiers |
| Sc√©nario 5 | ‚≠ê‚≠ê Moyen | 20 pts | Variables, secrets, s√©curit√© |
| Sc√©nario 6 | ‚≠ê‚≠ê‚≠ê Difficile | 20 pts | Optimisation, performance |
| **Total** | | **100 pts** | |

---

## üìù Livrables attendus

Pour chaque sc√©nario, fournissez :
1. ‚úÖ **Le fichier `.gitlab-ci.yml` corrig√©**
2. ‚úÖ **Une explication des erreurs trouv√©es**
3. ‚úÖ **Les tests de validation** (commandes pour v√©rifier que √ßa fonctionne)
4. ‚úÖ **Les le√ßons apprises** (qu'avez-vous compris ?)

---

## üéì M√©thodologie de debug

Pour chaque sc√©nario, suivez cette m√©thode :

1. **Lire les logs** attentivement (cherchez "ERROR", "FATAL", "failed")
2. **V√©rifier la syntaxe** YAML (indentation, deux-points, tirets)
3. **Valider les d√©pendances** entre jobs (graphe logique)
4. **Contr√¥ler les chemins** de fichiers et artifacts
5. **V√©rifier les variables** et leur disponibilit√©
6. **Tester localement** si possible avec `gitlab-runner exec`

---

## üîó Ressources utiles

- [GitLab CI/CD YAML syntax reference](https://docs.gitlab.com/ee/ci/yaml/)
- [Validateur YAML en ligne](https://www.yamllint.com/)
- [GitLab CI/CD troubleshooting](https://docs.gitlab.com/ee/ci/troubleshooting.html)
- [Docker-in-Docker](https://docs.gitlab.com/ee/ci/docker/using_docker_build.html)

---

**Bon debug ! üêûüîß**
